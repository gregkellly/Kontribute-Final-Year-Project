import { ActorConfig, ActorSubclass } from "@dfinity/agent";
import { InterfaceFactory } from "@dfinity/candid/lib/cjs/idl";
import { HttpAgentOptionsSyncIdentity } from "./createActor";
import { PartitionKey, SortKey } from "./CanDBTypes";
import { BaseIndexCanisterType, IndexCanisterTypeWrapper, IndexClient } from "./IndexClient";
export interface ActorOptions {
    /**
     * The Actor IDL
     */
    IDL: InterfaceFactory;
    /**
     * Agent options for the ActorClient
     */
    agentOptions: HttpAgentOptionsSyncIdentity;
    /**
     * Actor options for the ActorClient
     */
    actorConfig?: ActorConfig;
}
/**
 * Contains the mimumum viable methods that an actor canister must implement
 *
 * For example, all actors must have an skExists() method to be able to use the ActorClient
 */
export declare type BaseActorClientType = {
    skExists: (arg_0: string) => Promise<boolean>;
};
/**
 * The ActorClient allows for a frontend to interface with one or many canisters that share a specific Internet Computer Actor type.
 *
 * @example
 * ```typescript
 * // Example of creating an ActorClient for interfacing with one or many User Actor canisters
 *
 * import { IndexCanister } from "..<path_to>/declarations/index/index.did"; // from generated index canister declaration files
 * import { UserCanister } from "..<path_to>/declarations/user/user.did"; // from generated user canister declaration files
 * import { idlFactory as UserCanisterIDL } from "..<path_to>/declarations/user"; // from generated user canister declaration files
 *
 * const userActorClient = new ActorClient<IndexCanister, UserCanister>({
 *   actorOptions: {
 *     IDL: UserCanisterIDL,
 *     agentOptions: {
 *       host: <insert_host>,
 *       identity: <insert_identity>
 *     },
 *   },
 *   indexClient: <insert_index_client>
 * });
 * ```
 *
 * @typeparam IndexCanisterType the canister interface (generated) for the index canister
 * @typeparam ActorCanisterType the canister interface (generated) for this specific actor client
 */
export declare class ActorClient<IndexCanisterType extends BaseIndexCanisterType = never, ActorCanisterType extends BaseActorClientType = never> {
    /**
     * @ignore
     */
    private actorOptions;
    /**
     * @ignore
     */
    private indexClient;
    constructor(options: {
        /**
         * Options specific to the actor client being instantiated
         */
        actorOptions: ActorOptions;
        /**
         * The {@link IndexClient} connected to the index canister that is associated with this actor
         */
        indexClient: IndexClient<IndexCanisterTypeWrapper<IndexCanisterType>>;
    });
    /**
     * @ignore
     */
    private createActorsFromCanisters;
    /**
     * Use to call a query function on all canisters with a specific PK
     *
     * @example
     * ```typescript
     * // Example calling the getPK() method defined on canisters with a specific PK via the User Actor
     *
     * const responses = await userActorClient.query<UserCanister["getPK"]>(
     *   PK,
     *   (actor) => actor.getPK()
     * );
     * ```
     *
     * @type @param F - Type parameter with the IDL actor type and function
     *   For example, userActorClient.request<UserCanister["getPK"]>, where F is UserCanister["getPK"]
     *
     * @param PK - Partition Key
     * @param queryFn - the query function that will be executed on the canister. Takes in an actor and
     *   returns the ReturnType of F
     * @param useCache - whether the index canister needs to be hit again to fetch relevant PK canisters,
     *   or if the request can use the PK to canister cache list to query directly without needing to do so
     *
     * @returns {Promise<PromiseSettledResult<Awaited<ReturnType<F>>[]} - An array of settled promises of
     *   the query ReturnType.
     */
    query<F extends (...args: any[]) => ReturnType<F>>(PK: PartitionKey, queryFn: (actor: ActorSubclass<ActorCanisterType>) => ReturnType<F>, useCache?: boolean): Promise<PromiseSettledResult<Awaited<ReturnType<F>>>[]>;
    /**
     * Note: may remove this function depending on utilization - (originally wrote this to retrieve canister specific metrics for the hackathon demo)
     *
     * Similar to query, but returns a mapping of canisterId to the query result returned by that canister.
     *
     * Important if want canister level information for a pk and don't want to go through the indexing canister. This
     * is because going through the indexing canister would slow it down massively in a large multi-canister application
     *
     * @type @param F - Type parameter with the IDL actor type and function
     *   For example, userActorClient.request<UserCanister["getPK"]>, where F is UserCanister["getPK"]
     *
     * @param PK - Partition Key
     * @param queryFn - the query function that will be executed on the canister. Takes in an actor and
     *   returns the ReturnType of F
     * @param useCache - whether the index canister needs to be hit again to fetch relevant PK canisters,
     *   or if the request can use the PK to canister cache list to query directly without needing to do so
     *
     * @returns - a promise settled result mapping of canisterId to the result of the query (TypeDoc fail - see source code for return type)
     */
    queryWithCanisterIdMapping<F extends (...args: any[]) => ReturnType<F>>(PK: PartitionKey, queryFn: (actor: ActorSubclass<ActorCanisterType>) => ReturnType<F>, useCache?: boolean): Promise<PromiseSettledResult<Awaited<{
        [canisterId: string]: ReturnType<F>;
    }>>[]>;
    /**
     * Use to call a query function on all canisters with a specific PK, and then to reduce that result
     *
     * @example
     * ```typescript
     * // An example making a query call to a getCount endpoint that returns a count, and then passing a reducer function that will reduce the response from potentially multiple canisters
     *
     * function reducer(acc: bigint, settledResult: PromiseSettledResult<Awaited<bigint>>): bigint {
     *   if (settledResult.status === "rejected") { return acc; };
     *   return acc + settledResult.value;
     * };
     *
     * const reducedResult = await userActorClient.queryReduce<UserCanister["getCount"], bigint>(
     *   PK,
     *   (actor) => actor.getCount(),
     *   reducer,
     *   BigInt(0)
     * );
     *
     * console.log("reduced result", reducedResult);
     * ```
     *
     * @type @param F - Type parameter with the IDL actor type and function
     *   For example, userActorClient.request<UserCanister["getPK"]>, where F is UserCanister["getPK"]
     * @type @param U - Type parameter signifying the return type of the reducer function
     *
     * @param PK - Partition Key
     * @param queryFn - the query function that will be executed on the canister. Takes in an actor and
     *   returns the ReturnType of F
     * @param reducer  - function to reduce the array result of the query function being called on one or more canisters
     * @param initialValue - intial value for the reducer
     * @param useCache - whether the index canister needs to be hit again to fetch relevant PK canisters,
     *   or if the request can use the PK to canister cache list to query directly without needing to do so
     *
     * @returns {Promise<PromiseSettledResult<Awaited<ReturnType<F>>[]} - An array of settled promises of
     *   the query ReturnType.
     *
     * @param PK
     * @param queryFn
     * @param reducer
     * @param initialValue
     * @param useCache
     * @returns
     */
    queryReduce<F extends (...args: any[]) => Promise<any>, U>(PK: PartitionKey, queryFn: (actor: ActorSubclass<ActorCanisterType>) => ReturnType<F>, reducer: (accumulator: U, current: PromiseSettledResult<Awaited<ReturnType<F>>>) => U, initialValue: U, useCache?: boolean): Promise<U>;
    /**
     * Calls an update method on a single canister actor with the specific PK and SK.
     *
     * If multiple canisters with the PK exist, first makes a query call to each canister to see if the SK exists.
     *
     * @example
     * ```typescript
     * // An example making an update call to an updateUserAttributes endpoint that updates a specific user's attributes
     *
     *
     * let updateUserAttributesResult = await userActorClient.update<UserCanister["updateUserAttributes"]>(
     *   <insert PK>,
     *   <insert SK>,
     *   (actor) => actor.updateUserAttributes(attributes)
     * );
     *
     * console.log("result", updateUserAttributesResult);
     * ```
     *
     * @type @param F - Type parameter with the IDL actor type and function
     *    For example, userActorClient.request<UserCanister["<myUpdateFunction"]>, where F is UserCanister["<myUpdateFunction"]
     *
     * @param pk - partition key
     * @param sk - sort key
     * @param updateFn - update function to be called on the given actor
     * @returns - a promise with the result of the update function
     */
    update<F extends (...args: any[]) => ReturnType<F>>(pk: PartitionKey, sk: SortKey, updateFn: (actor: ActorSubclass<ActorCanisterType>) => ReturnType<F>): Promise<ReturnType<F>>;
}
